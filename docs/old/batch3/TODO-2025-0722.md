# ğŸ­ RimAI Framework å¯¹è¯ç³»ç»Ÿ v3.0 å®æ–½è®¡åˆ’

**åŸºäºç°æœ‰v3.0æ¶æ„çš„æ™ºèƒ½å¯¹è¯ç³»ç»Ÿ**

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

### ğŸ¯ è®¾è®¡ç›®æ ‡
æ„å»ºä¸€ä¸ªç»Ÿä¸€çš„å¯¹è¯ç³»ç»Ÿï¼Œæ”¯æŒå¤šç§å¯¹è¯æ¨¡å¼å’Œè¾“å‡ºæ ¼å¼ï¼š
- **å¯¹è¯æ¨¡å¼**ï¼š1å¯¹1 å¯¹è¯ï¼ˆç©å®¶å¯¹NPCã€NPCå¯¹NPCï¼‰ã€å¤šå¯¹å¤š ç¾¤ä½“å¯¹è¯
- **è¾“å‡ºæ ¼å¼**ï¼šæµå¼/éæµå¼ã€JSON/æ–‡æœ¬ã€æ‰¹å¤„ç†æ”¯æŒ
- **åœºæ™¯é©±åŠ¨**ï¼šæ‰€æœ‰å¯¹è¯éƒ½åŸºäºåœºæ™¯æç¤ºè¯
- **æ¡†æ¶é›†æˆ**ï¼šå……åˆ†åˆ©ç”¨ç°æœ‰æ‰¹å¤„ç†ã€ç¼“å­˜ã€é…ç½®ç­‰ç‰¹æ€§
- **æ™ºèƒ½ç®¡ç†**ï¼šå†å²è®°å½•ã€Tokenæ§åˆ¶ã€å†…å®¹èˆå¼ƒã€æ™ºèƒ½æ€»ç»“

### ğŸ—ï¸ æ¶æ„è®¾è®¡
```
RimAIå¯¹è¯ç³»ç»Ÿæ¶æ„
â”œâ”€â”€ ConversationManager (å¯¹è¯ç®¡ç†å™¨)
â”‚   â”œâ”€â”€ 1v1 å¯¹è¯
â”‚   â”‚   â”œâ”€â”€ ç©å®¶ vs NPC
â”‚   â”‚   â””â”€â”€ NPC vs NPC
â”‚   â””â”€â”€ NvN å¤šè§’è‰²å¯¹è¯
â”œâ”€â”€ ScenarioEngine (åœºæ™¯å¼•æ“)
â”‚   â”œâ”€â”€ åœºæ™¯æç¤ºè¯ç®¡ç†
â”‚   â””â”€â”€ ä¸Šä¸‹æ–‡æ„å»º
â”œâ”€â”€ OutputProcessor (è¾“å‡ºå¤„ç†å™¨)
â”‚   â”œâ”€â”€ æµå¼/éæµå¼åˆ‡æ¢
â”‚   â”œâ”€â”€ JSON/æ–‡æœ¬æ ¼å¼åŒ–
â”‚   â””â”€â”€ æ‰¹å¤„ç†æ”¯æŒ
â”œâ”€â”€ HistoryManager (å†å²ç®¡ç†å™¨)
â”‚   â”œâ”€â”€ å¯¹è¯æ¡ç›®æ§åˆ¶
â”‚   â”œâ”€â”€ Tokenè®¡æ•°ä¸èˆå¼ƒ
â”‚   â””â”€â”€ æ™ºèƒ½æ€»ç»“
â””â”€â”€ ç°æœ‰æ¡†æ¶é›†æˆ
    â”œâ”€â”€ RequestBatcher (æ‰¹å¤„ç†)
    â”œâ”€â”€ ResponseCache (ç¼“å­˜)
    â”œâ”€â”€ RimAIConfiguration (é…ç½®)
    â””â”€â”€ LLMManager (LLMç®¡ç†)
```

---

## ğŸš€ æ ¸å¿ƒç»„ä»¶è®¾è®¡

### 1. å¯¹è¯ç®¡ç†å™¨ (ConversationManager)

#### 1.1 ç»Ÿä¸€å¯¹è¯æ¥å£
**æ–‡ä»¶**: `RimAI.Framework/Source/Conversation/ConversationManager.cs`ï¼ˆæ–°å»ºï¼‰
```csharp
public static class ConversationManager
{
    /// <summary>
    /// ç»Ÿä¸€å¯¹è¯API - æ”¯æŒæ‰€æœ‰æ¨¡å¼å’Œæ ¼å¼
    /// </summary>
    public static async Task<ConversationResult> StartConversationAsync(ConversationRequest request)
    {
        try
        {
            // 1. åœºæ™¯éªŒè¯ä¸åˆå§‹åŒ–
            var scenario = await ScenarioEngine.LoadScenarioAsync(request.ScenarioId);
            if (scenario == null)
                throw new ArgumentException($"åœºæ™¯ä¸å­˜åœ¨: {request.ScenarioId}");

            // 2. æ ¹æ®æ¨¡å¼é€‰æ‹©å¤„ç†å™¨
            IConversationProcessor processor = request.Mode switch
            {
                ConversationMode.OneToOne => new SingleCharacterProcessor(),
                ConversationMode.MultiParty => new MultiCharacterProcessor(),
                _ => throw new ArgumentException($"ä¸æ”¯æŒçš„å¯¹è¯æ¨¡å¼: {request.Mode}")
            };

            // 3. å†å²è®°å½•ç®¡ç†
            var history = await HistoryManager.PrepareHistoryAsync(request.SessionId, request.Options);

            // 4. æ‰§è¡Œå¯¹è¯
            var context = new ConversationContext
            {
                Request = request,
                Scenario = scenario,
                History = history,
                Options = request.Options ?? new ConversationOptions()
            };

            return await processor.ProcessAsync(context);
        }
        catch (Exception ex)
        {
            RimAILogger.LogError($"å¯¹è¯å¤±è´¥: {ex.Message}");
            return ConversationResult.Failed(ex.Message);
        }
    }
}
```

#### 1.2 å¯¹è¯è¯·æ±‚æ¨¡å‹
```csharp
public class ConversationRequest
{
    public string SessionId { get; set; } = Guid.NewGuid().ToString();
    public ConversationMode Mode { get; set; } = ConversationMode.OneToOne;
    public ConversationType Type { get; set; } = ConversationType.PlayerToNPC;
    public string ScenarioId { get; set; } // å¿…éœ€ï¼šåœºæ™¯ID
    public string Message { get; set; } // ç”¨æˆ·è¾“å…¥æˆ–NPCè¾“å…¥
    public string InitiatorId { get; set; } = "Player"; // å‘èµ·è€…IDï¼ˆç©å®¶æˆ–NPCï¼‰
    public string TargetId { get; set; } // ç›®æ ‡è§’è‰²IDï¼ˆ1v1æ¨¡å¼ï¼‰
    public List<string> ParticipantIds { get; set; } = new(); // å¤šå¯¹å¤šæ¨¡å¼çš„å‚ä¸è€…
    public ConversationOptions Options { get; set; } = new();
}

public enum ConversationMode
{
    OneToOne,    // 1å¯¹1 å¯¹è¯
    MultiParty   // å¤šå¯¹å¤š ç¾¤ä½“å¯¹è¯
}

public enum ConversationType
{
    PlayerToNPC,  // ç©å®¶å¯¹NPC
    NPCToNPC     // NPCå¯¹NPC
}

public class ConversationOptions
{
    // è¾“å‡ºæ ¼å¼æ§åˆ¶
    public bool IsStreaming { get; set; } = false;
    public bool OutputAsJson { get; set; } = false;
    public bool EnableBatching { get; set; } = false;
    
    // å†å²è®°å½•æ§åˆ¶
    public int MaxHistoryEntries { get; set; } = 20;
    public int MaxTokens { get; set; } = 4000;
    public bool EnableTokenControl { get; set; } = true;
    public bool EnableSmartSummary { get; set; } = true;
    
    // å¯¹è¯å‚æ•°
    public float Temperature { get; set; } = 0.7f;
    public int MaxResponseTokens { get; set; } = 1000;
    public int MaxResponseTokensPerCharacter { get; set; } = 100; // å¤šè§’è‰²æ¨¡å¼ä¸‹æ¯ä¸ªè§’è‰²çš„å›åº”é™åˆ¶
    public Dictionary<string, object> CustomParameters { get; set; } = new();
}
```

### 2. åœºæ™¯å¼•æ“ (ScenarioEngine)

#### 2.1 åœºæ™¯ç®¡ç†
**æ–‡ä»¶**: `RimAI.Framework/Source/Conversation/ScenarioEngine.cs`ï¼ˆæ–°å»ºï¼‰
```csharp
public static class ScenarioEngine
{
    private static readonly ResponseCache _cache = ResponseCache.Instance;
    
    public static async Task<ConversationScenario> LoadScenarioAsync(string scenarioId)
    {
        return await _cache.GetOrAddAsync($"scenario:{scenarioId}", 
            async () => await LoadScenarioFromConfig(scenarioId),
            TimeSpan.FromMinutes(30));
    }
    
    public static string BuildContextPrompt(ConversationScenario scenario, ConversationHistory history, ConversationRequest request)
    {
        var builder = new StringBuilder();
        
        // 1. åœºæ™¯è®¾å®š
        builder.AppendLine("# å¯¹è¯åœºæ™¯");
        builder.AppendLine(scenario.Description);
        builder.AppendLine();
        
        // 2. å®Œæ•´è§’è‰²è®¾å®šï¼ˆå¤šè§’è‰²æ¨¡å¼ä¸‹æ‰€æœ‰äººéƒ½éœ€è¦äº†è§£å½¼æ­¤ï¼‰
        if (scenario.Characters?.Any() == true)
        {
            builder.AppendLine("# å‚ä¸è§’è‰²");
            foreach (var character in scenario.Characters)
            {
                builder.AppendLine($"â€¢ {character.Name}: {character.Description ?? GetCharacterSummary(character.SystemPrompt)}");
            }
            builder.AppendLine();
        }
        
        // 3. ç¾¤èŠå†å²è®°å½•ï¼ˆä¼˜åŒ–Tokenä½¿ç”¨ï¼‰
        if (history?.Messages?.Any() == true)
        {
            builder.AppendLine("# ç¾¤èŠè®°å½•");
            var recentMessages = GetOptimizedHistory(history.Messages, request.Options);
            foreach (var msg in recentMessages)
            {
                var timestamp = msg.Timestamp.ToString("HH:mm");
                builder.AppendLine($"[{timestamp}] {msg.Sender}: {msg.Content}");
            }
            builder.AppendLine();
        }
        
        // 4. å½“å‰è¾“å…¥
        builder.AppendLine("# æœ€æ–°å‘è¨€");
        if (request.Type == ConversationType.PlayerToNPC)
        {
            builder.AppendLine($"ç©å®¶: {request.Message}");
        }
        else if (request.Type == ConversationType.NPCToNPC)
        {
            builder.AppendLine($"{request.InitiatorId}: {request.Message}");
            if (!string.IsNullOrEmpty(request.TargetId))
            {
                builder.AppendLine($"(å›åº”å¯¹è±¡: {request.TargetId})");
            }
        }
        
        return builder.ToString();
    }
    
    /// <summary>
    /// è·å–è§’è‰²ç®€è¦æè¿°ï¼ˆä»SystemPromptæå–å…³é”®ä¿¡æ¯ï¼‰
    /// </summary>
    private static string GetCharacterSummary(string systemPrompt)
    {
        if (string.IsNullOrEmpty(systemPrompt))
            return "æœªçŸ¥è§’è‰²";
            
        // æå–ç¬¬ä¸€å¥è¯ä½œä¸ºç®€è¦æè¿°
        var firstSentence = systemPrompt.Split('ã€‚', '!', 'ï¼')[0];
        return firstSentence.Length > 50 ? firstSentence.Substring(0, 47) + "..." : firstSentence;
    }
    
    /// <summary>
    /// è·å–ä¼˜åŒ–çš„å†å²è®°å½•ï¼ˆæ§åˆ¶Tokenæ•°é‡ï¼‰
    /// </summary>
    private static List<ConversationMessage> GetOptimizedHistory(List<ConversationMessage> messages, ConversationOptions options)
    {
        if (!messages.Any()) return new List<ConversationMessage>();
        
        var maxHistoryTokens = options.MaxTokens / 3; // å†å²è®°å½•å æ€»Tokençš„1/3
        var optimizedMessages = new List<ConversationMessage>();
        var currentTokens = 0;
        
        // ä»æœ€æ–°æ¶ˆæ¯å¼€å§‹å¾€å›é€‰æ‹©
        for (int i = messages.Count - 1; i >= 0; i--)
        {
            var msg = messages[i];
            var msgTokens = EstimateTokens($"[{msg.Timestamp:HH:mm}] {msg.Sender}: {msg.Content}");
            
            if (currentTokens + msgTokens <= maxHistoryTokens)
            {
                optimizedMessages.Insert(0, msg);
                currentTokens += msgTokens;
            }
            else
            {
                break;
            }
        }
        
        return optimizedMessages;
    }
}

public class ConversationScenario
{
    public string Id { get; set; }
    public string Name { get; set; }
    public string Description { get; set; } // åœºæ™¯æç¤ºè¯
    public List<CharacterConfig> Characters { get; set; } = new();
    public ScenarioType Type { get; set; } = ScenarioType.General;
    public Dictionary<string, object> Settings { get; set; } = new();
}

public class CharacterConfig
{
    public string Id { get; set; } // è§’è‰²å”¯ä¸€æ ‡è¯†
    public string Name { get; set; } // è§’è‰²æ˜¾ç¤ºåç§°
    public string Description { get; set; } // è§’è‰²æè¿°
    public string SystemPrompt { get; set; } // è§’è‰²ç³»ç»Ÿæç¤ºè¯
    public List<string> Tags { get; set; } = new(); // è§’è‰²æ ‡ç­¾
    public bool IsEnabled { get; set; } = true; // æ˜¯å¦å¯ç”¨
    public Dictionary<string, object> Attributes { get; set; } = new(); // æ‰©å±•å±æ€§
}

public enum ScenarioType
{
    General,        // é€šç”¨åœºæ™¯
    Technical,      // æŠ€æœ¯è®¨è®º
    Creative,       // åˆ›æ„å†™ä½œ
    Analysis,       // åˆ†æè®ºè¯
    Roleplay        // è§’è‰²æ‰®æ¼”
}
```

### 3. è¾“å‡ºå¤„ç†å™¨ (OutputProcessor)

#### 3.1 å¤šæ ¼å¼è¾“å‡ºæ”¯æŒ
**æ–‡ä»¶**: `RimAI.Framework/Source/Conversation/OutputProcessor.cs`ï¼ˆæ–°å»ºï¼‰
```csharp
public static class OutputProcessor
{
    public static async Task<ConversationResult> ProcessOutputAsync(
        string rawContent, ConversationContext context)
    {
        var options = context.Options;
        
        // 1. åŸºç¡€å“åº”æ„å»º
        var result = new ConversationResult
        {
            IsSuccess = true,
            SessionId = context.Request.SessionId,
            Timestamp = DateTime.UtcNow,
            Mode = context.Request.Mode
        };
        
        // 2. æ ¼å¼åŒ–å¤„ç†
        if (options.OutputAsJson)
        {
            result.JsonResponse = FormatAsJson(rawContent, context);
            result.ContentType = "application/json";
        }
        else
        {
            result.TextResponse = rawContent;
            result.ContentType = "text/plain";
        }
        
        // 3. æµå¼å¤„ç†
        if (options.IsStreaming)
        {
            result.StreamingSupported = true;
            result.StreamCallback = CreateStreamCallback(context);
        }
        
        // 4. æ‰¹å¤„ç†æ ‡è®°
        if (options.EnableBatching)
        {
            result.BatchId = context.Request.SessionId;
            result.BatchSupported = true;
        }
        
        return result;
    }
    
    private static object FormatAsJson(string content, ConversationContext context)
    {
        return new
        {
            session_id = context.Request.SessionId,
            mode = context.Request.Mode.ToString().ToLower(),
            scenario = context.Scenario.Name,
            timestamp = DateTime.UtcNow.ToString("yyyy-MM-ddTHH:mm:ssZ"),
            response = new
            {
                content = content,
                character_count = content.Length,
                estimated_tokens = EstimateTokens(content)
            },
            metadata = new
            {
                temperature = context.Options.Temperature,
                max_tokens = context.Options.MaxResponseTokens,
                processing_time_ms = 0 // å®é™…å¤„ç†æ—¶é—´
            }
        };
    }
    
    private static Func<string, Task> CreateStreamCallback(ConversationContext context)
    {
        return async (chunk) =>
        {
            // åˆ©ç”¨ç°æœ‰çš„æµå¼å¤„ç†æœºåˆ¶
            await RimAIAPI.StreamAsync(chunk, context.Options.CustomParameters);
        };
    }
}
```

### 4. å†å²ç®¡ç†å™¨ (HistoryManager)

#### 4.1 æ™ºèƒ½å†å²è®°å½•ç®¡ç†
**æ–‡ä»¶**: `RimAI.Framework/Source/Conversation/HistoryManager.cs`ï¼ˆæ–°å»ºï¼‰
```csharp
public static class HistoryManager
{
    private static readonly ResponseCache _cache = ResponseCache.Instance;
    
    public static async Task<ConversationHistory> PrepareHistoryAsync(string sessionId, ConversationOptions options)
    {
        var history = await GetHistoryAsync(sessionId);
        
        if (options.EnableTokenControl)
        {
            history = await OptimizeHistoryForTokens(history, options);
        }
        
        if (history.Messages.Count > options.MaxHistoryEntries)
        {
            history = await TrimHistoryWithSummary(history, options);
        }
        
        return history;
    }
    
    public static async Task AddMessageAsync(string sessionId, ConversationMessage message)
    {
        var historyKey = $"conversation_history:{sessionId}";
        var history = await _cache.GetOrAddAsync(historyKey,
            () => Task.FromResult(new ConversationHistory { SessionId = sessionId }),
            TimeSpan.FromHours(4));
            
        history.Messages.Add(message);
        await _cache.SetAsync(historyKey, history, TimeSpan.FromHours(4));
    }
    
    /// <summary>
    /// Tokenæ•°æ£€æŸ¥ä¸å†…å®¹èˆå¼ƒ
    /// </summary>
    private static async Task<ConversationHistory> OptimizeHistoryForTokens(
        ConversationHistory history, ConversationOptions options)
    {
        var currentTokens = history.Messages.Sum(m => EstimateTokens(m.Content));
        
        if (currentTokens <= options.MaxTokens)
            return history;
            
        // ä¿ç•™æœ€æ–°æ¶ˆæ¯ï¼Œé€æ­¥ç§»é™¤æ—§æ¶ˆæ¯
        var optimizedHistory = new ConversationHistory { SessionId = history.SessionId };
        var reversedMessages = history.Messages.AsEnumerable().Reverse().ToList();
        var tokenCount = 0;
        
        foreach (var message in reversedMessages)
        {
            var messageTokens = EstimateTokens(message.Content);
            if (tokenCount + messageTokens <= options.MaxTokens)
            {
                optimizedHistory.Messages.Insert(0, message);
                tokenCount += messageTokens;
            }
            else
            {
                break;
            }
        }
        
        return optimizedHistory;
    }
    
    /// <summary>
    /// æ™ºèƒ½æ€»ç»“ - è¶…å‡ºæ¡ç›®æ•°æ—¶è‡ªåŠ¨æ€»ç»“
    /// </summary>
    private static async Task<ConversationHistory> TrimHistoryWithSummary(
        ConversationHistory history, ConversationOptions options)
    {
        if (!options.EnableSmartSummary || history.Messages.Count <= options.MaxHistoryEntries)
            return history;
            
        // å–å‡ºè¦æ€»ç»“çš„æ¶ˆæ¯ï¼ˆä¿ç•™æœ€æ–°çš„ä¸€åŠï¼‰
        var keepCount = options.MaxHistoryEntries / 2;
        var toSummarize = history.Messages.Take(history.Messages.Count - keepCount).ToList();
        var toKeep = history.Messages.Skip(history.Messages.Count - keepCount).ToList();
        
        // ç”Ÿæˆæ€»ç»“
        var summaryPrompt = BuildSummaryPrompt(toSummarize);
        var summaryResponse = await RimAIAPI.SendMessageAsync(summaryPrompt, new LLMRequestOptions
        {
            Temperature = 0.3f,
            MaxTokens = 200
        });
        
        // æ„å»ºæ–°çš„å†å²è®°å½•
        var newHistory = new ConversationHistory { SessionId = history.SessionId };
        newHistory.Messages.Add(new ConversationMessage
        {
            Sender = "ç³»ç»Ÿ",
            Content = $"[å¯¹è¯æ€»ç»“] {summaryResponse?.Content ?? "æ— æ³•ç”Ÿæˆæ€»ç»“"}",
            Timestamp = DateTime.UtcNow,
            MessageType = MessageType.Summary
        });
        newHistory.Messages.AddRange(toKeep);
        
        return newHistory;
    }
    
    private static int EstimateTokens(string text)
    {
        if (string.IsNullOrEmpty(text)) return 0;
        
        // ä¼˜åŒ–çš„Tokenä¼°ç®—ï¼ˆä¸å¤šè§’è‰²å¤„ç†å™¨ä¿æŒä¸€è‡´ï¼‰
        var chineseChars = text.Count(c => c >= 0x4e00 && c <= 0x9fff);
        var englishWords = text.Split(' ', StringSplitOptions.RemoveEmptyEntries)
                              .Count(word => word.Any(char.IsLetter));
        var punctuation = text.Count(char.IsPunctuation);
        
        return (int)(chineseChars / 1.5 + englishWords + punctuation * 0.5);
    }
}

public class ConversationHistory
{
    public string SessionId { get; set; }
    public List<ConversationMessage> Messages { get; set; } = new();
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime LastUpdated { get; set; } = DateTime.UtcNow;
}

public class ConversationMessage
{
    public string Sender { get; set; }
    public string Content { get; set; }
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;
    public MessageType MessageType { get; set; } = MessageType.User;
    public Dictionary<string, object> Metadata { get; set; } = new();
}

public enum MessageType
{
    User,
    Assistant,
    System,
    Summary
}
```

### 5. å¤„ç†å™¨å®ç°

#### 5.1 å•è§’è‰²å¤„ç†å™¨
**æ–‡ä»¶**: `RimAI.Framework/Source/Conversation/Processors/SingleCharacterProcessor.cs`ï¼ˆæ–°å»ºï¼‰
```csharp
public class SingleCharacterProcessor : IConversationProcessor
{
    public async Task<ConversationResult> ProcessAsync(ConversationContext context)
    {
        // 1. æ„å»ºæç¤ºè¯
        var prompt = ScenarioEngine.BuildContextPrompt(
            context.Scenario, context.History, context.Request);
            
        // 2. æ ¹æ®å¯¹è¯ç±»å‹é€‰æ‹©å“åº”è§’è‰²
        CharacterConfig responseCharacter = null;
        string senderName = "";
        
        if (context.Request.Type == ConversationType.PlayerToNPC)
        {
            // ç©å®¶å¯¹NPCï¼šé€‰æ‹©ç›®æ ‡NPCæˆ–æœ€åˆé€‚çš„NPC
            responseCharacter = GetTargetCharacter(context.Scenario, context.Request.TargetId) 
                             ?? SelectBestCharacter(context.Scenario, context.Request.Message);
            senderName = "ç©å®¶";
        }
        else if (context.Request.Type == ConversationType.NPCToNPC)
        {
            // NPCå¯¹NPCï¼šé€‰æ‹©ç›®æ ‡NPC
            responseCharacter = GetTargetCharacter(context.Scenario, context.Request.TargetId);
            senderName = context.Request.InitiatorId;
            
            if (responseCharacter == null)
            {
                return ConversationResult.Failed($"ç›®æ ‡è§’è‰² '{context.Request.TargetId}' ä¸å­˜åœ¨");
            }
        }
        
        // 3. æ„å»ºå®Œæ•´æç¤ºè¯
        if (responseCharacter != null)
        {
            var rolePrompt = BuildRolePrompt(responseCharacter, context.Request);
            prompt = $"{rolePrompt}\n\n{prompt}";
        }
        
        // 4. å‘é€è¯·æ±‚
        var llmOptions = new LLMRequestOptions
        {
            Temperature = context.Options.Temperature,
            MaxTokens = context.Options.MaxResponseTokens,
            IsStreaming = context.Options.IsStreaming
        };
        
        var response = await RimAIAPI.SendMessageAsync(prompt, llmOptions);
        
        // 5. å¤„ç†å“åº”
        if (response?.IsSuccess == true)
        {
            // ä¿å­˜åˆ°å†å²è®°å½•
            await HistoryManager.AddMessageAsync(context.Request.SessionId, new ConversationMessage
            {
                Sender = senderName,
                Content = context.Request.Message,
                MessageType = context.Request.Type == ConversationType.PlayerToNPC ? MessageType.User : MessageType.Assistant
            });
            
            await HistoryManager.AddMessageAsync(context.Request.SessionId, new ConversationMessage
            {
                Sender = responseCharacter?.Name ?? "ç³»ç»Ÿ",
                Content = response.Content,
                MessageType = MessageType.Assistant
            });
            
            return await OutputProcessor.ProcessOutputAsync(response.Content, context);
        }
        
        return ConversationResult.Failed("æ— æ³•è·å–å“åº”");
    }
    
    private CharacterConfig GetTargetCharacter(ConversationScenario scenario, string targetId)
    {
        if (string.IsNullOrEmpty(targetId) || scenario.Characters == null)
            return null;
            
        return scenario.Characters.FirstOrDefault(c => 
            c.Name.Equals(targetId, StringComparison.OrdinalIgnoreCase) ||
            c.Id?.Equals(targetId, StringComparison.OrdinalIgnoreCase) == true);
    }
    
    private string BuildRolePrompt(CharacterConfig character, ConversationRequest request)
    {
        var builder = new StringBuilder();
        builder.AppendLine($"ä½ ç°åœ¨æ‰®æ¼”è§’è‰²: {character.Name}");
        builder.AppendLine(character.SystemPrompt);
        
        if (request.Type == ConversationType.NPCToNPC)
        {
            builder.AppendLine($"\nè¯·é’ˆå¯¹ {request.InitiatorId} çš„è¯è¯­åšå‡ºåˆé€‚çš„å›åº”ã€‚");
            builder.AppendLine("ä¿æŒè§’è‰²çš„ä¸ªæ€§å’Œç«‹åœºï¼Œå›åº”è¦è‡ªç„¶ã€ç¬¦åˆè§’è‰²è®¾å®šã€‚");
        }
        
        return builder.ToString();
    }
}
```

#### 5.2 å¤šè§’è‰²å¤„ç†å™¨
**æ–‡ä»¶**: `RimAI.Framework/Source/Conversation/Processors/MultiCharacterProcessor.cs`ï¼ˆæ–°å»ºï¼‰
```csharp
public class MultiCharacterProcessor : IConversationProcessor
{
    private static readonly RequestBatcher<CharacterRequest, string> _batcher = 
        new RequestBatcher<CharacterRequest, string>(ProcessBatch, 
            batchSize: 5, windowMs: 200, maxConcurrentBatches: 3);
    
    public async Task<ConversationResult> ProcessAsync(ConversationContext context)
    {
        // 1. ç¡®å®šå‚ä¸è§’è‰²
        var participants = DetermineParticipants(context);
        if (!participants.Any())
        {
            return ConversationResult.Failed("æ²¡æœ‰å¯ç”¨çš„å‚ä¸è§’è‰²");
        }
        
                 // 2. æ„å»ºæ‰¹å¤„ç†è¯·æ±‚
        var requests = participants.Select(character => new CharacterRequest
        {
            Character = character,
            Context = context,
            Prompt = ScenarioEngine.BuildContextPrompt(context.Scenario, context.History, context.Request)
        }).ToList();
        
        // 3. å¹¶è¡Œå¤„ç†ï¼ˆåˆ©ç”¨ç°æœ‰æ‰¹å¤„ç†ç³»ç»Ÿï¼‰
        var responses = await _batcher.AddBatchAsync(requests);
        
        // 4. ç»„è£…å¤šè§’è‰²å“åº”
        var multiResponse = new StringBuilder();
        var characterResponses = new List<CharacterResponse>();
        
        for (int i = 0; i < responses.Count; i++)
        {
            var character = participants[i];
            var content = responses[i];
            
            characterResponses.Add(new CharacterResponse
            {
                CharacterName = character.Name,
                Content = content,
                Timestamp = DateTime.UtcNow
            });
            
            multiResponse.AppendLine($"**{character.Name}**: {content}");
            multiResponse.AppendLine();
        }
        
        // 5. ä¿å­˜å†å²è®°å½•
        await SaveMultiCharacterHistory(context, characterResponses);
        
        // 6. å¤„ç†è¾“å‡º
        var result = await OutputProcessor.ProcessOutputAsync(multiResponse.ToString(), context);
        result.MultiCharacterResponses = characterResponses;
        
        return result;
    }
    
    private static async Task<List<string>> ProcessBatch(List<CharacterRequest> requests)
    {
        var tasks = requests.Select(async request =>
        {
            // æ„å»ºè§’è‰²ç‰¹å®šçš„å®Œæ•´æç¤ºè¯
            var rolePrompt = BuildCharacterRolePrompt(request.Character);
            var fullPrompt = $"{rolePrompt}\n\n{request.Prompt}";
            
            // ä¸¥æ ¼é™åˆ¶æ¯ä¸ªè§’è‰²çš„å›åº”é•¿åº¦ï¼ˆé»˜è®¤100 Tokenï¼‰
            var maxTokens = request.Context.Options.MaxResponseTokensPerCharacter;
            
            // éªŒè¯æ€»æç¤ºè¯é•¿åº¦ï¼Œé˜²æ­¢æº¢å‡º
            var promptTokens = EstimateTokens(fullPrompt);
            if (promptTokens > request.Context.Options.MaxTokens - maxTokens)
            {
                RimAILogger.LogWarning($"è§’è‰² {request.Character.Name} çš„æç¤ºè¯è¿‡é•¿ ({promptTokens} tokens)ï¼Œå¯èƒ½å½±å“å›åº”è´¨é‡");
            }
            
            var response = await RimAIAPI.SendMessageAsync(fullPrompt, new LLMRequestOptions
            {
                Temperature = request.Context.Options.Temperature,
                MaxTokens = maxTokens // ä½¿ç”¨ä¸¥æ ¼çš„Tokené™åˆ¶
            });
            
            return response?.Content ?? $"[{request.Character.Name} æ— æ³•å›åº”æ­¤è¯é¢˜]";
        });
        
        return (await Task.WhenAll(tasks)).ToList();
    }
    
    /// <summary>
    /// æ„å»ºè§’è‰²ç‰¹å®šçš„æç¤ºè¯ï¼ˆåŒ…å«ç®€æ´çš„æŒ‡å¯¼åŸåˆ™ï¼‰
    /// </summary>
    private static string BuildCharacterRolePrompt(CharacterConfig character)
    {
        return $@"ä½ ç°åœ¨æ‰®æ¼”: {character.Name}
{character.SystemPrompt}

é‡è¦æŒ‡å¯¼åŸåˆ™:
- ä¿æŒè§’è‰²ä¸ªæ€§ï¼Œå›åº”ç®€æ´æœ‰åŠ›ï¼ˆå»ºè®®50-80å­—ï¼‰
- é’ˆå¯¹æœ€æ–°å‘è¨€åšå‡ºè‡ªç„¶ååº”
- è€ƒè™‘å…¶ä»–è§’è‰²çš„ç«‹åœºå’Œå…³ç³»
- å¦‚æœä¸éœ€è¦å‘è¨€ï¼Œå¯ä»¥è¯´""[ä¿æŒæ²‰é»˜]""æˆ–ç®€çŸ­è¡¨æ€";
    }
    
    /// <summary>
    /// Tokenä¼°ç®—å·¥å…·ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
    /// </summary>
    private static int EstimateTokens(string text)
    {
        if (string.IsNullOrEmpty(text)) return 0;
        
        // æ›´ç²¾ç¡®çš„Tokenä¼°ç®—
        var chineseChars = text.Count(c => c >= 0x4e00 && c <= 0x9fff);
        var englishWords = text.Split(' ', StringSplitOptions.RemoveEmptyEntries)
                              .Count(word => word.Any(char.IsLetter));
        var punctuation = text.Count(char.IsPunctuation);
        
        // ä¸­æ–‡å­—ç¬¦çº¦1.5å­—ç¬¦/tokenï¼Œè‹±æ–‡å•è¯çº¦1 word/tokenï¼Œæ ‡ç‚¹ç¬¦å·çº¦0.5ä¸ª/token
        return (int)(chineseChars / 1.5 + englishWords + punctuation * 0.5);
    }
}
```

---

## ğŸ“Š é…ç½®ç¤ºä¾‹

### åœºæ™¯é…ç½®
```json
{
  "Scenarios": {
    "tech_discussion": {
      "Name": "æŠ€æœ¯è®¨è®º",
      "Description": "è¿™æ˜¯ä¸€ä¸ªæŠ€æœ¯è®¨è®ºåœºæ™¯ï¼Œå‚ä¸è€…å°†ä»ä¸åŒè§’åº¦åˆ†ææŠ€æœ¯é—®é¢˜ã€‚è¯·ä¿æŒä¸“ä¸šã€å®¢è§‚ã€æœ‰å»ºè®¾æ€§çš„è®¨è®ºæ€åº¦ã€‚",
      "Type": "Technical",
             "Characters": [
         {
           "Id": "architect",
           "Name": "æ¶æ„å¸ˆ",
           "Description": "èµ„æ·±ç³»ç»Ÿæ¶æ„å¸ˆï¼Œå…³æ³¨å¯æ‰©å±•æ€§å’Œæ€§èƒ½",
           "SystemPrompt": "ä½ æ˜¯ä¸€ä½èµ„æ·±ç³»ç»Ÿæ¶æ„å¸ˆï¼Œæ“…é•¿ä»æ¶æ„è®¾è®¡è§’åº¦åˆ†æé—®é¢˜ï¼Œå…³æ³¨å¯æ‰©å±•æ€§ã€æ€§èƒ½å’Œç»´æŠ¤æ€§ã€‚",
           "Tags": ["æ¶æ„", "è®¾è®¡", "æ€§èƒ½"]
         },
         {
           "Id": "developer", 
           "Name": "å¼€å‘å·¥ç¨‹å¸ˆ",
           "Description": "å®æˆ˜ç»éªŒä¸°å¯Œçš„å¼€å‘å·¥ç¨‹å¸ˆï¼Œæ³¨é‡å®ç°æ•ˆç‡",
           "SystemPrompt": "ä½ æ˜¯ä¸€ä½å®æˆ˜ç»éªŒä¸°å¯Œçš„å¼€å‘å·¥ç¨‹å¸ˆï¼Œæ³¨é‡ä»£ç å®ç°çš„å¯è¡Œæ€§å’Œå¼€å‘æ•ˆç‡ã€‚",
           "Tags": ["ç¼–ç ", "å®ç°", "æ•ˆç‡"]
         },
         {
           "Id": "tester",
           "Name": "æµ‹è¯•ä¸“å®¶", 
           "Description": "è´¨é‡ä¿è¯ä¸“å®¶ï¼Œå…³æ³¨æµ‹è¯•ç­–ç•¥å’Œé£é™©æ§åˆ¶",
           "SystemPrompt": "ä½ æ˜¯ä¸€ä½æµ‹è¯•ä¸“å®¶ï¼Œä»è´¨é‡ä¿è¯è§’åº¦è€ƒè™‘é—®é¢˜ï¼Œå…³æ³¨æµ‹è¯•ç­–ç•¥å’Œé£é™©æ§åˆ¶ã€‚",
           "Tags": ["æµ‹è¯•", "è´¨é‡", "é£é™©"]
         }
       ]
    },
    "creative_writing": {
      "Name": "åˆ›æ„å†™ä½œ",
      "Description": "è¿™æ˜¯ä¸€ä¸ªåˆ›æ„å†™ä½œåœºæ™¯ï¼Œå‚ä¸è€…å°†åä½œåˆ›ä½œå†…å®¹ã€‚é¼“åŠ±åˆ›æ–°æ€ç»´å’Œè‰ºæœ¯è¡¨è¾¾ã€‚",
      "Type": "Creative",
             "Characters": [
         {
           "Id": "writer",
           "Name": "ä½œå®¶",
           "SystemPrompt": "ä½ æ˜¯ä¸€ä½å¯Œæœ‰æƒ³è±¡åŠ›çš„ä½œå®¶ï¼Œæ“…é•¿åˆ›ä½œå¼•äººå…¥èƒœçš„æ•…äº‹å’Œç”ŸåŠ¨çš„æè¿°ã€‚",
           "Tags": ["å†™ä½œ", "æ•…äº‹", "åˆ›æ„"]
         },
         {
           "Id": "editor",
           "Name": "ç¼–è¾‘",
           "SystemPrompt": "ä½ æ˜¯ä¸€ä½ä¸“ä¸šç¼–è¾‘ï¼Œå…³æ³¨æ–‡æœ¬çš„ç»“æ„ã€é€»è¾‘å’Œè¯­è¨€è¡¨è¾¾è´¨é‡ã€‚",
           "Tags": ["ç¼–è¾‘", "ç»“æ„", "è¯­è¨€"]
         }
       ]
    }
  }
}
```

---

## ğŸ¯ ä½¿ç”¨ç¤ºä¾‹

### 1å¯¹1 å¯¹è¯ç¤ºä¾‹
```csharp
// ç®€å•çš„1å¯¹1å¯¹è¯
var response = await ConversationManager.StartConversationAsync(new ConversationRequest
{
    Mode = ConversationMode.OneToOne,
    ScenarioId = "tech_discussion",
    Message = "å¦‚ä½•ä¼˜åŒ–Reactåº”ç”¨çš„æ€§èƒ½ï¼Ÿ",
    Options = new ConversationOptions
    {
        IsStreaming = false,
        OutputAsJson = false,
        MaxHistoryEntries = 10
    }
});

Console.WriteLine(response.TextResponse);
```

### å¤šå¯¹å¤š å¯¹è¯ç¤ºä¾‹
```csharp
// å¤šè§’è‰²ç¾¤ä½“è®¨è®º - ä¸¥æ ¼Tokenæ§åˆ¶
var response = await ConversationManager.StartConversationAsync(new ConversationRequest
{
    Mode = ConversationMode.MultiParty,
    ScenarioId = "tech_discussion",
    Message = "å¾®æœåŠ¡æ¶æ„çš„ä¼˜ç¼ºç‚¹æ˜¯ä»€ä¹ˆï¼Ÿ",
    ParticipantIds = new List<string> { "architect", "developer", "tester" },
    Options = new ConversationOptions
    {
        OutputAsJson = false,
        EnableBatching = true,
        MaxTokens = 3000,
        MaxResponseTokensPerCharacter = 100, // æ¯ä¸ªè§’è‰²æœ€å¤š100 Token
        EnableSmartSummary = true,
        EnableTokenControl = true
    }
});

// é¢„æœŸè¾“å‡ºæ ¼å¼
Console.WriteLine(response.TextResponse);
/* è¾“å‡ºç¤ºä¾‹ï¼š
**æ¶æ„å¸ˆ**: å¾®æœåŠ¡æ¶æ„çš„ä¸»è¦ä¼˜åŠ¿æ˜¯è§£è€¦å’Œç‹¬ç«‹éƒ¨ç½²ï¼Œä½†ä¼šå¢åŠ ç³»ç»Ÿå¤æ‚æ€§å’Œç½‘ç»œå¼€é”€ã€‚éœ€è¦æˆç†Ÿçš„DevOpsæ”¯æŒã€‚

**å¼€å‘å·¥ç¨‹å¸ˆ**: ä»å¼€å‘è§’åº¦çœ‹ï¼Œå¾®æœåŠ¡ç¡®å®æé«˜äº†å›¢é˜Ÿç‹¬ç«‹æ€§ï¼Œä½†è°ƒè¯•å’Œæµ‹è¯•å˜å¾—æ›´å›°éš¾ã€‚æœåŠ¡é—´é€šä¿¡çš„é”™è¯¯å¤„ç†æ˜¯ä¸ªæŒ‘æˆ˜ã€‚

**æµ‹è¯•ä¸“å®¶**: æµ‹è¯•ç­–ç•¥éœ€è¦é‡æ–°è®¾è®¡ã€‚å•å…ƒæµ‹è¯•ç›¸å¯¹ç®€å•ï¼Œä½†é›†æˆæµ‹è¯•å’Œç«¯åˆ°ç«¯æµ‹è¯•å¤æ‚åº¦å¤§å¹…å¢åŠ ã€‚éœ€è¦è‰¯å¥½çš„æœåŠ¡æ¨¡æ‹Ÿæœºåˆ¶ã€‚
*/
```

### æµå¼å¯¹è¯ç¤ºä¾‹
```csharp
// æµå¼è¾“å‡ºå¯¹è¯
var response = await ConversationManager.StartConversationAsync(new ConversationRequest
{
    Mode = ConversationMode.OneToOne,
    ScenarioId = "creative_writing",
    Message = "å†™ä¸€ä¸ªå…³äºAIçš„ç§‘å¹»çŸ­æ•…äº‹",
    Options = new ConversationOptions
    {
        IsStreaming = true,
        MaxResponseTokens = 1500
    }
});

// æµå¼å¤„ç†
if (response.StreamingSupported && response.StreamCallback != null)
{
    await response.StreamCallback("å¼€å§‹æµå¼è¾“å‡º...");
}
```

### NPCå¯¹NPC å¯¹è¯ç¤ºä¾‹
```csharp
// NPCä¹‹é—´çš„å¯¹è¯ - æ¶æ„å¸ˆå¯¹å¼€å‘å·¥ç¨‹å¸ˆ
var response = await ConversationManager.StartConversationAsync(new ConversationRequest
{
    Mode = ConversationMode.OneToOne,
    Type = ConversationType.NPCToNPC,
    ScenarioId = "tech_discussion",
    InitiatorId = "æ¶æ„å¸ˆ",
    TargetId = "developer",
    Message = "è¿™ä¸ªå¾®æœåŠ¡çš„APIè®¾è®¡éœ€è¦è€ƒè™‘å‘åå…¼å®¹æ€§ï¼Œä½ è§‰å¾—åº”è¯¥å¦‚ä½•å®ç°ç‰ˆæœ¬æ§åˆ¶ï¼Ÿ",
    Options = new ConversationOptions
    {
        OutputAsJson = false,
        MaxHistoryEntries = 15,
        EnableSmartSummary = true
    }
});

Console.WriteLine($"{response.TextResponse}");

// ç»§ç»­å¯¹è¯ - å¼€å‘å·¥ç¨‹å¸ˆå›åº”åï¼Œæµ‹è¯•ä¸“å®¶åŠ å…¥
var followUpResponse = await ConversationManager.StartConversationAsync(new ConversationRequest
{
    SessionId = response.SessionId, // ä½¿ç”¨åŒä¸€ä¼šè¯
    Mode = ConversationMode.OneToOne,
    Type = ConversationType.NPCToNPC,
    ScenarioId = "tech_discussion",
    InitiatorId = "å¼€å‘å·¥ç¨‹å¸ˆ",
    TargetId = "tester",
    Message = "æˆ‘ä»¬åˆšè®¨è®ºäº†APIç‰ˆæœ¬æ§åˆ¶çš„æ–¹æ¡ˆï¼Œä»æµ‹è¯•è§’åº¦ä½ æœ‰ä»€ä¹ˆå»ºè®®ï¼Ÿ",
    Options = new ConversationOptions
    {
        MaxTokens = 3000,
        EnableTokenControl = true
    }
});
```

### è§’è‰²æ‰®æ¼”å¯¹è¯ç¤ºä¾‹
```csharp
// åˆ›å»ºä¸€ä¸ªæ®–æ°‘åœ°è§’è‰²å¯¹è¯åœºæ™¯
var colonyResponse = await ConversationManager.StartConversationAsync(new ConversationRequest
{
    Mode = ConversationMode.OneToOne,
    Type = ConversationType.NPCToNPC,
    ScenarioId = "colony_life", // å‡è®¾æœ‰æ®–æ°‘åœ°ç”Ÿæ´»åœºæ™¯
    InitiatorId = "åŒ»ç”Ÿè¨æ‹‰",
    TargetId = "å·¥ç¨‹å¸ˆæ±¤å§†",
    Message = "æ±¤å§†ï¼ŒåŒ»ç–—èˆ±çš„æ°§æ°”å¾ªç¯ç³»ç»Ÿå‡ºç°äº†é—®é¢˜ï¼Œä½ èƒ½æ¥çœ‹çœ‹å—ï¼Ÿ",
    Options = new ConversationOptions
    {
        Temperature = 0.8f, // ç¨é«˜æ¸©åº¦å¢åŠ å¯¹è¯è‡ªç„¶åº¦
        MaxResponseTokens = 300
    }
});
```

---

## âš¡ æ ¸å¿ƒä¼˜åŠ¿

### âœ… ç»Ÿä¸€æ¶æ„
- **ä¸€å¥—API**: ç»Ÿä¸€æ¥å£æ”¯æŒæ‰€æœ‰å¯¹è¯æ¨¡å¼å’Œè¾“å‡ºæ ¼å¼
- **åœºæ™¯é©±åŠ¨**: æ‰€æœ‰å¯¹è¯éƒ½åŸºäºå¯é…ç½®çš„åœºæ™¯æç¤ºè¯
- **æ¡†æ¶é›†æˆ**: å……åˆ†åˆ©ç”¨ç°æœ‰çš„æ‰¹å¤„ç†ã€ç¼“å­˜ã€é…ç½®ç³»ç»Ÿ

### ğŸ§  æ™ºèƒ½ç®¡ç†
- **è‡ªåŠ¨å†å²ä¼˜åŒ–**: åŸºäºTokenæ•°å’Œæ¡ç›®æ•°çš„æ™ºèƒ½å†å²ç®¡ç†
- **æ™ºèƒ½æ€»ç»“**: è¶…å‡ºé™åˆ¶æ—¶è‡ªåŠ¨ç”Ÿæˆå¯¹è¯æ€»ç»“
- **å†…å®¹èˆå¼ƒ**: ç²¾ç¡®çš„Tokenæ§åˆ¶å’Œå†…å®¹ä¼˜å…ˆçº§ç®¡ç†

### ğŸš€ é«˜æ€§èƒ½
- **å¹¶è¡Œå¤„ç†**: å¤šè§’è‰²å¯¹è¯åˆ©ç”¨æˆç†Ÿçš„æ‰¹å¤„ç†ç³»ç»Ÿ
- **æ™ºèƒ½ç¼“å­˜**: åœºæ™¯ã€å†å²è®°å½•å¤šå±‚ç¼“å­˜
- **æµå¼æ”¯æŒ**: å®Œæ•´çš„æµå¼è¾“å‡ºèƒ½åŠ›

### ğŸ”§ çµæ´»é…ç½®
- **å¤šè¾“å‡ºæ ¼å¼**: æ”¯æŒæ–‡æœ¬ã€JSONã€æµå¼ã€æ‰¹å¤„ç†
- **å¯æ‰©å±•æ€§**: åœºæ™¯å’Œè§’è‰²å®Œå…¨å¯é…ç½®
- **å‚æ•°æ§åˆ¶**: ä¸°å¯Œçš„å¯¹è¯å‚æ•°å’Œé€‰é¡¹

## ğŸ›ï¸ ç¾¤ä½“å¯¹è¯Tokenæ§åˆ¶æœ€ä½³å®è·µ

### âš¡ **ä¸¥æ ¼Tokené™åˆ¶ç­–ç•¥**

#### ä¸ºä»€ä¹ˆéœ€è¦100 Tokené™åˆ¶ï¼Ÿ
1. **æˆæœ¬æ§åˆ¶**: 4ä¸ªè§’è‰² Ã— 100 Token = æœ€å¤š400 Tokenè¾“å‡ºï¼Œå¯é¢„æµ‹çš„è´¹ç”¨
2. **ç”¨æˆ·ä½“éªŒ**: é¿å…æŸä¸ªè§’è‰²"éœ¸å "å¯¹è¯ï¼Œä¿æŒè‡ªç„¶èŠ‚å¥
3. **å“åº”æ•ˆç‡**: çŸ­å›åº”æ›´ç¬¦åˆçœŸå®ç¾¤ä½“å¯¹è¯çš„ç‰¹ç‚¹
4. **ç³»ç»Ÿç¨³å®š**: é˜²æ­¢Tokenæº¢å‡ºå¯¼è‡´çš„APIé”™è¯¯

#### Tokenåˆ†é…ç­–ç•¥
```csharp
public class ConversationOptions
{
    public int MaxTokens { get; set; } = 4000;                    // æ€»Tokené™åˆ¶
    public int MaxResponseTokensPerCharacter { get; set; } = 100; // æ¯è§’è‰²å›åº”é™åˆ¶
    
    // Tokenåˆ†é…åŸåˆ™ï¼š
    // - åœºæ™¯æè¿°: ~200 Token
    // - è§’è‰²åˆ—è¡¨: ~150 Token  
    // - ç¾¤èŠå†å²: ~1000 Token (åŠ¨æ€è°ƒæ•´)
    // - å½“å‰è¾“å…¥: ~50 Token
    // - é¢„ç•™è¾“å‡º: è§’è‰²æ•° Ã— 100 Token
    // - å®‰å…¨è¾¹è·: ~500 Token
}
```

### ğŸ“± **ç¾¤èŠè®°å½•æ ¼å¼è®¾è®¡**

#### ä¼˜åŒ–çš„å†å²è®°å½•æ ¼å¼
```
# ç¾¤èŠè®°å½•
[14:23] æ€»ç£: å¤§å®¶éƒ½å¬å¥½äº†ï¼Œä»¥åæˆ‘ä»¬æ®–æ°‘åœ°åªè¦å†æ¥é‚£äº›ä¸ä¸‰ä¸å››çš„å•†é˜Ÿï¼Œæ¯ä¸ªäººéƒ½æœ‰ä¸»åŠ¨å¼€ç«çš„æƒåŠ›ï¼
[14:24] å®‰å…¨ä¸»ç®¡è‰¾ä¼¦: æ˜ç™½ï¼Œæ€»ç£ï¼ä¸è¿‡æˆ‘å»ºè®®åˆ¶å®šå¨èƒè¯†åˆ«æ ‡å‡†ï¼Œé¿å…è¯¯ä¼¤ã€‚
[14:24] å•†äººç›ä¸½: è¿™å¯èƒ½ä¼šå½±å“æ­£å¸¸è´¸æ˜“...ä¹Ÿè®¸å…ˆå»ºç«‹é»‘åå•ï¼Ÿ
[14:25] åŒ»ç”Ÿé™ˆåšå£«: æˆ‘æ‹…å¿ƒä¼šå¯¼è‡´ä¸å¿…è¦çš„å†²çªå’Œä¼¤äº¡ã€‚
```

#### Tokenä¼˜åŒ–æŠ€å·§
- **æ—¶é—´æˆ³ç®€åŒ–**: ä½¿ç”¨`HH:mm`æ ¼å¼ï¼ŒèŠ‚çœToken
- **å†å²è®°å½•æˆªæ–­**: åŠ¨æ€è®¡ç®—ï¼Œä¿ç•™æœ€é‡è¦çš„ä¸Šä¸‹æ–‡
- **è§’è‰²æè¿°å‹ç¼©**: ç”¨ç®€æ´æè¿°ä»£æ›¿å®Œæ•´SystemPrompt

### ğŸ” **æ™ºèƒ½Tokenç®¡ç†**

#### åŠ¨æ€å†å²è®°å½•è°ƒæ•´
```csharp
private static List<ConversationMessage> GetOptimizedHistory(
    List<ConversationMessage> messages, ConversationOptions options)
{
    var maxHistoryTokens = options.MaxTokens / 3; // å†å²è®°å½•å 1/3
    // ä»æœ€æ–°æ¶ˆæ¯å‘å‰é€‰æ‹©ï¼Œç›´åˆ°Tokené™åˆ¶
    // ä¿è¯æ¯ä¸ªå‚ä¸è§’è‰²éƒ½æœ‰å‘è¨€è®°å½•
}
```

#### Tokenæº¢å‡ºé¢„é˜²
```csharp
// éªŒè¯æ€»æç¤ºè¯é•¿åº¦
var promptTokens = EstimateTokens(fullPrompt);
if (promptTokens > maxTokens - responseTokens)
{
    // è®°å½•è­¦å‘Šï¼Œä½†ç»§ç»­æ‰§è¡Œ
    // ç³»ç»Ÿä¼šè‡ªåŠ¨æˆªæ–­è¿‡é•¿çš„å†å²è®°å½•
}
```

### ğŸ“Š **å®é™…Tokenä½¿ç”¨ç¤ºä¾‹**

#### æ€»ç£é›†ä¼šåœºæ™¯ Tokenåˆ†æ
```
åœºæ™¯æè¿°: 120 Token
å‚ä¸è§’è‰²: 80 Token (4ä¸ªè§’è‰² Ã— 20 Token/è§’è‰²)
ç¾¤èŠå†å²: 300 Token (çº¦6-8æ¡å†å²æ¶ˆæ¯)
å½“å‰è¾“å…¥: 45 Token (æ€»ç£çš„å®£å‘Š)
è§’è‰²æç¤º: 160 Token (4ä¸ªè§’è‰² Ã— 40 Token/è§’è‰²)
å®‰å…¨è¾¹è·: 295 Token
------------------
æ€»è¾“å…¥: 1000 Token

é¢„æœŸè¾“å‡º: 400 Token (4ä¸ªè§’è‰² Ã— 100 Token/è§’è‰²)
------------------
æ€»æ¶ˆè€—: 1400 Token âœ…
```

### ğŸ¯ **æœ€ä½³å®è·µå»ºè®®**

1. **è§’è‰²æ•°é‡æ§åˆ¶**: å»ºè®®3-5ä¸ªè§’è‰²ï¼Œè¶…è¿‡5ä¸ªä¼šå¯¼è‡´Tokenç´§å¼ 
2. **å›åº”é•¿åº¦æŒ‡å¯¼**: åœ¨è§’è‰²æç¤ºä¸­æ˜ç¡®è¦æ±‚"ç®€æ´æœ‰åŠ›ï¼ˆ50-80å­—ï¼‰"
3. **å†å²è®°å½•ç®¡ç†**: å®šæœŸæ¸…ç†æˆ–æ€»ç»“ï¼Œé¿å…ä¸Šä¸‹æ–‡è¿‡é•¿
4. **åœºæ™¯æè¿°ä¼˜åŒ–**: åœºæ™¯æè¿°åº”ç®€æ´æ˜ç¡®ï¼Œé¿å…å†—é•¿èƒŒæ™¯
5. **Tokenç›‘æ§**: å®æ—¶ç›‘æ§Tokenä½¿ç”¨æƒ…å†µï¼ŒåŠæ—¶è°ƒæ•´ç­–ç•¥

---

*ğŸ¯ ç°ä»£åŒ–å¯¹è¯ç³»ç»Ÿï¼Œç»Ÿä¸€æ¥å£ï¼Œæ™ºèƒ½ç®¡ç†ï¼Œé«˜æ€§èƒ½å¹¶è¡Œå¤„ç†ï¼*  
*ğŸ’¡ é€šè¿‡ä¸¥æ ¼çš„Tokenæ§åˆ¶ï¼Œç¡®ä¿ç¾¤ä½“å¯¹è¯æ—¢ç”ŸåŠ¨åˆç»æµé«˜æ•ˆï¼* 